// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var BaseDAO, Promise, _, knex, knexConf, moduleKeywords,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  knexConf = require(process.cwd() + '/knexfile');

  knex = require('knex')(knexConf[process.env.NODE_ENV]);

  _ = require('underscore');

  Promise = require('bluebird');

  moduleKeywords = ['extended', 'included'];

  BaseDAO = (function() {
    BaseDAO.applyConfiguration = function(obj) {
      var key, ref, value;
      this.prototype.config = {};
      for (key in obj) {
        value = obj[key];
        if (indexOf.call(moduleKeywords, key) < 0) {
          this.prototype.config[key] = value;
        }
      }
      if ((ref = obj.included) != null) {
        ref.apply(this);
      }
      return this;
    };

    function BaseDAO(model) {
      this._validateOrderBy = bind(this._validateOrderBy, this);
      if (this.config == null) {
        this.config = {};
      }
      this.config.model = model;
      if (this.config.lookupField == null) {
        this.config.lookupField = this.config.model.metadata.primaryKey;
      }
      _.each(this.config.returning, (function(_this) {
        return function(returningArray, key) {
          return _.each(returningArray, function(field) {
            if (!(field in _this.config.model.prototype.attributes) && field !== '*') {
              throw new Error("Field '" + field + "' of 'config.returning' of " + _this.config.model.metadata.model + " is not an attribute of this model.");
            }
          });
        };
      })(this));
    }

    BaseDAO.prototype._translateReturningToDatabase = function(returning) {
      var defaultReturningArray, finalReturningArray, returningArray, tempReturningArray;
      if ((returning != null) && _.isArray(returning)) {
        tempReturningArray = _.each(returning, (function(_this) {
          return function(field) {
            if (_.isString(field) && field in _this.config.model.prototype.attributes && (_this.config.model.prototype.attributes[field].attributes.abstract == null)) {
              return field;
            } else {
              throw new Error("Field '" + field + "' from " + _this.config.model.metadata.model + " is not an attribute of this model or is set as an 'abstract'.");
            }
          };
        })(this));
      } else if ((returning != null) && _.isString(returning)) {
        if (returning in this.config.returning) {
          defaultReturningArray = this.config.returning[returning];
        } else {
          throw new Error("Returning '" + returning + "' is not one of dao.config.returning of '" + this.config.model.metadata.model + "'.");
        }
      } else if ((returning == null) || ((returning != null) && !_.isArray(returning) && !_.isString(returning))) {
        defaultReturningArray = (this.config.returning != null) && (this.config.returning.basic != null) ? this.config.returning.basic : ['*'];
      }
      if ((defaultReturningArray != null) && _.contains(defaultReturningArray, '*')) {
        tempReturningArray = _.map(this.config.model.prototype.attributes, (function(_this) {
          return function(fieldVal, modelField) {
            if ((fieldVal.attributes.abstract == null) && !(modelField in _this.config.model.prototype.timestampAttributes)) {
              return "" + modelField;
            }
          };
        })(this));
      } else if (defaultReturningArray != null) {
        tempReturningArray = _.clone(defaultReturningArray);
      }
      returningArray = _.without(tempReturningArray, void 0);
      if (_.indexOf(returningArray, this.config.model.metadata.primaryKey) === -1) {
        returningArray.unshift(this.config.model.metadata.primaryKey);
      }
      finalReturningArray = _.map(returningArray, (function(_this) {
        return function(field) {
          return (_this.config.model.prototype.attributes[field].getDbField(field)) + " AS " + field;
        };
      })(this));
      return finalReturningArray;
    };

    BaseDAO.prototype._validateOrderBy = function(orderBy) {
      var column, orderByObject;
      if ((orderBy != null) && typeof orderBy === 'string' && orderBy.charAt(0) !== '-' && orderBy in this.config.model.prototype.attributes) {
        column = this.config.model.prototype.attributes[orderBy].attributes.dbField;
        orderByObject = {
          column: column,
          direction: 'asc'
        };
      } else if ((orderBy != null) && typeof orderBy === 'string' && orderBy.charAt(0) === '-' && orderBy.substr(1) in this.config.model.prototype.attributes) {
        column = this.config.model.prototype.attributes[orderBy.substr(1)].attributes.dbField;
        orderByObject = {
          column: column,
          direction: 'desc'
        };
      } else if (orderBy != null) {
        throw new Error("'orderBy' attribute of '" + this.constructor.name + "' method should be attribute of " + this.config.model.metadata.model + ", optionaly with '-' sign!");
      } else {
        orderByObject = {
          column: this.config.model.metadata.primaryKey,
          direction: 'asc'
        };
      }
      return orderByObject;
    };

    BaseDAO.prototype.getById = function(arg) {
      var error, error1, pk, ref, returning, returningArray, toObject;
      ref = arg != null ? arg : {}, pk = ref.pk, returning = ref.returning, toObject = ref.toObject;
      if (toObject == null) {
        toObject = true;
      }
      if (pk == null) {
        throw new Error("'getById' method requires value for 'pk' parameter!");
      }
      try {
        returningArray = this._translateReturningToDatabase(returning);
      } catch (error1) {
        error = error1;
        return new Promise(function(resolve, reject) {
          return reject(error);
        });
      }
      return knex(this.config.model.metadata.tableName).where(this.config.model.metadata.primaryKey, pk).andWhere('is_deleted', false).select(returningArray).then((function(_this) {
        return function(rows) {
          if (rows.length > 1) {
            throw new Error("'getById()' method on '" + _this.config.model.metadata.model + "' returned more than 1 row!");
          }
          if (toObject && rows.length === 1) {
            return new _this.config.model(rows[0]);
          }
          return rows[0];
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          if (_this.config.errorLogger != null) {
            _this.config.errorLogger.error(error);
          }
          throw error;
        };
      })(this));
    };

    BaseDAO.prototype.get = function(arg) {
      var error, error1, lookup, ref, returning, returningArray, toObject, where;
      ref = arg != null ? arg : {}, lookup = ref.lookup, returning = ref.returning, toObject = ref.toObject;
      if (toObject == null) {
        toObject = true;
      }
      if (lookup == null) {
        throw new Error("'get()' method requires value for 'lookup' parameter!");
      }
      where = {};
      _.each(lookup, (function(_this) {
        return function(val, key) {
          var databaseKey;
          if (!(key in _this.config.model.prototype.attributes)) {
            throw new Error("'" + key + "' does not match any attribute of model '" + _this.config.model.metadata.model + "' in '.get()' method of DAO");
          }
          databaseKey = _this.config.model.prototype.attributes[key].getDbField(key);
          return where[databaseKey] = val;
        };
      })(this));
      try {
        returningArray = this._translateReturningToDatabase(returning);
      } catch (error1) {
        error = error1;
        return new Promise(function(resolve, reject) {
          return reject(error);
        });
      }
      return knex(this.config.model.metadata.tableName).where(where).andWhere('is_deleted', false).select(returningArray).then((function(_this) {
        return function(rows) {
          if (rows.length > 1) {
            throw new Error("'get()' method on '" + _this.config.model.metadata.tableName + "' returned more than 1 row!");
          }
          if (toObject && rows.length === 1) {
            return new _this.config.model(rows[0]);
          }
          return rows[0];
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          if (_this.config.errorLogger != null) {
            _this.config.errorLogger.error(error);
          }
          throw error;
        };
      })(this));
    };

    BaseDAO.prototype.all = function(arg) {
      var error, error1, knexQuery, orderBy, orderByObject, ref, returning, returningArray, toObject;
      ref = arg != null ? arg : {}, returning = ref.returning, toObject = ref.toObject, orderBy = ref.orderBy;
      if (toObject == null) {
        toObject = true;
      }
      try {
        returningArray = this._translateReturningToDatabase(returning);
        orderByObject = this._validateOrderBy(orderBy);
      } catch (error1) {
        error = error1;
        return new Promise(function(resolve, reject) {
          return reject(error);
        });
      }
      knexQuery = knex(this.config.model.metadata.tableName).select(returningArray).where('is_deleted', false);
      if (orderByObject != null) {
        knexQuery.orderBy(orderByObject.column, orderByObject.direction);
      }
      return knexQuery.then((function(_this) {
        return function(rows) {
          if (toObject && rows.length > 0) {
            return _.map(rows, function(val, key) {
              return new _this.config.model(val);
            });
          }
          return rows;
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          if (_this.config.errorLogger != null) {
            _this.config.errorLogger.error(error);
          }
          throw error;
        };
      })(this));
    };

    BaseDAO.prototype.filterPaged = function(arg) {
      var error, error1, limit, lookup, orderBy, orderByObject, page, returning, returningArray, toObject;
      lookup = arg.lookup, orderBy = arg.orderBy, returning = arg.returning, toObject = arg.toObject, limit = arg.limit, page = arg.page;
      if (lookup == null) {
        lookup = {};
      }
      lookup['is_deleted'] = false;
      if (toObject == null) {
        toObject = true;
      }
      try {
        returningArray = this._translateReturningToDatabase(returning);
        orderByObject = this._validateOrderBy(orderBy);
      } catch (error1) {
        error = error1;
        return new Promise(function(resolve, reject) {
          return reject(error);
        });
      }
      return knex(this.config.model.metadata.tableName).select(returningArray).where(lookup).orderBy(orderByObject.column, orderByObject.direction).limit(limit).offset((page - 1) * limit).then(function(result) {
        return result;
      })["catch"](function(error) {
        throw error;
      });
    };

    BaseDAO.prototype.filter = function(arg) {
      var error, error1, lookup, model, orderBy, orderByObject, query, ref, returning, returningArray, toObject;
      ref = arg != null ? arg : {}, lookup = ref.lookup, returning = ref.returning, toObject = ref.toObject, orderBy = ref.orderBy;
      if (toObject == null) {
        toObject = true;
      }
      if (lookup == null) {
        lookup = [
          {
            key: 'where',
            values: {}
          }
        ];
      }
      try {
        returningArray = this._translateReturningToDatabase(returning);
        orderByObject = this._validateOrderBy(orderBy);
      } catch (error1) {
        error = error1;
        return new Promise(function(resolve, reject) {
          return reject(error);
        });
      }
      query = knex(this.config.model.metadata.tableName).select(returningArray);
      model = this.config.model;
      _.each(lookup, function(val) {
        var databaseKey;
        if (typeof val.values[0] === 'object' && !(_.isEmpty(val.values[0]))) {
          return query[val.key](function() {
            return _.each(val.values, (function(_this) {
              return function(nestedVal) {
                var databaseKey;
                databaseKey = model.prototype.attributes[nestedVal.values[0]].getDbField(nestedVal.values[0]);
                if (nestedVal.values.length === 2) {
                  return _this[nestedVal.key](databaseKey, nestedVal.values[1]);
                } else {
                  return _this[nestedVal.key](databaseKey, nestedVal.values[1], nestedVal.values[2]);
                }
              };
            })(this));
          });
        } else if (val.values instanceof Array) {
          databaseKey = model.prototype.attributes[val.values[0]].getDbField(val.values[0]);
          if (val.values.length === 2) {
            return query[val.key](databaseKey, val.values[1]);
          } else if (val.values.length === 3) {
            return query[val.key](databaseKey, val.values[1], val.values[2]);
          }
        }
      });
      query.andWhere('is_deleted', false);
      if (orderByObject != null) {
        query.orderBy(orderByObject.column, orderByObject.direction);
      }
      return query.then((function(_this) {
        return function(rows) {
          if (toObject && rows.length > 0) {
            return _.map(rows, function(val, key) {
              return new _this.config.model(val);
            });
          }
          return rows;
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          if (_this.config.errorLogger != null) {
            _this.config.errorLogger.error(error);
          }
          throw error;
        };
      })(this));
    };

    BaseDAO.prototype.create = function(arg) {
      var data, direct, error, error1, instance, ref, returning, returningArray, toObject, validationPromise;
      ref = arg != null ? arg : {}, data = ref.data, returning = ref.returning, toObject = ref.toObject, direct = ref.direct;
      if (toObject == null) {
        toObject = true;
      }
      if (direct == null) {
        direct = true;
      }
      try {
        returningArray = this._translateReturningToDatabase(returning);
      } catch (error1) {
        error = error1;
        return new Promise(function(resolve, reject) {
          return reject(error);
        });
      }
      validationPromise = null;
      if (direct) {
        instance = new this.config.model(data);
        validationPromise = instance.validate();
        data = instance._toDatabaseFields();
      }
      return Promise.all([validationPromise]).then((function(_this) {
        return function(validationErrors) {
          if (!(_.isEmpty(validationErrors[0]))) {
            throw validationErrors[0];
          }
          return knex(_this.config.model.metadata.tableName).insert(data, returningArray).then(function(rows) {
            if ((toObject != null) && rows.length === 1) {
              return new _this.config.model(rows[0]);
            }
            return rows[0];
          })["catch"](function(error) {
            if (_this.config.errorLogger != null) {
              _this.config.errorLogger.error(error);
            }
            throw error;
          });
        };
      })(this));
    };

    BaseDAO.prototype.bulkCreate = function(arg) {
      var data, error, error1, firstObject, insertedReturning, model, ref, returning, returningArray, tableName, toObject;
      ref = arg != null ? arg : {}, data = ref.data, returning = ref.returning, toObject = ref.toObject;
      if ((data == null) || !(data instanceof Array)) {
        throw new Error("'data' argument must be passed to the function and it must be an array!");
      }
      if (toObject == null) {
        toObject = true;
      }
      try {
        returningArray = this._translateReturningToDatabase(returning);
      } catch (error1) {
        error = error1;
        return new Promise(function(resolve, reject) {
          return reject(error);
        });
      }
      firstObject = new this.config.model(_.first(data));
      data.shift();
      model = this.config.model;
      tableName = this.config.model.metadata.tableName;
      insertedReturning = [];
      return knex.transaction(function(trx) {
        return firstObject.validate({
          trx: trx
        }).then(function(firstObjectValidation) {
          if (!(_.isEmpty(firstObjectValidation))) {
            throw firstObjectValidation;
          }
          return knex.insert(firstObject._toDatabaseFields(), returningArray).into(tableName).transacting(trx).then(function(result) {
            if (result.length === 1) {
              insertedReturning.push(_.first(result));
            } else {
              throw new Error("Error during 'bulkCreate' on " + model.metadata.model + "!");
            }
            return Promise.each(data, function(singleData) {
              var currentObject;
              currentObject = new model(singleData);
              return currentObject.validate({
                trx: trx
              }).then(function(currentObjectValidation) {
                if (!(_.isEmpty(currentObjectValidation))) {
                  throw currentObjectValidation;
                }
                return knex.insert(currentObject._toDatabaseFields(), returningArray).into(tableName).transacting(trx).then(function(result) {
                  if (result.length === 1) {
                    return insertedReturning.push(_.first(result));
                  } else {
                    throw new Error("Error during 'bulkCreate' on " + model.metadata.model + "!");
                  }
                });
              });
            });
          }).then(trx.commit)["catch"](trx.rollback);
        });
      }).then(function(inserts) {
        return insertedReturning;
      })["catch"]((function(_this) {
        return function(error) {
          if (_this.config.errorLogger != null) {
            _this.config.errorLogger.error(error);
          }
          throw error;
        };
      })(this));
    };

    BaseDAO.prototype.update = function(arg) {
      var error, error1, lookup, obj, ref, returning, returningArray, toObject;
      ref = arg != null ? arg : {}, obj = ref.obj, returning = ref.returning, toObject = ref.toObject;
      if (toObject == null) {
        toObject = true;
      }
      if (obj == null) {
        throw new Error("'update()' method needs model instance as 'obj' parameter!");
      } else if ((obj != null) && !(obj instanceof this.config.model)) {
        throw new Error("'obj' attribute passed to " + this.constructor.name + " 'update()' method should be an instance of " + this.config.model.metadata.model);
      }
      try {
        returningArray = this._translateReturningToDatabase(returning);
      } catch (error1) {
        error = error1;
        return new Promise(function(resolve, reject) {
          return reject(error);
        });
      }
      lookup = {};
      lookup[this.config.lookupField] = obj.get(this.config.lookupField);
      return knex(this.config.model.metadata.tableName).where(lookup).andWhere('is_deleted', false).update(obj._toDatabaseFields(), returningArray).then((function(_this) {
        return function(rows) {
          if ((toObject != null) && rows.length === 1) {
            return new _this.config.model(rows[0]);
          }
          return rows[0];
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          if (_this.config.errorLogger != null) {
            _this.config.errorLogger.error(error);
          }
          throw error;
        };
      })(this));
    };

    BaseDAO.prototype["delete"] = function(lookupValue, whoDeleted) {
      var deleteData, lookup;
      deleteData = {
        is_deleted: true
      };
      _.extend(deleteData, {
        'deleted_at': new Date()
      });
      if ((whoDeleted != null) && this.config.model.metadata.timestamps) {
        _.extend(deleteData, {
          'who_deleted_id': whoDeleted
        });
      }
      lookup = {};
      lookup[this.config.lookupField] = lookupValue;
      return knex(this.config.model.metadata.tableName).where(lookup).andWhere('is_deleted', false).update(deleteData).then(function(rows) {
        return rows;
      })["catch"]((function(_this) {
        return function(error) {
          if (_this.config.errorLogger != null) {
            _this.config.errorLogger.error(error);
          }
          throw error;
        };
      })(this));
    };

    BaseDAO.prototype.deleteMany = function(ids, whoDeleted) {
      var deleteData, deletedCounter;
      if (!(_.isArray(ids))) {
        throw new Error("First argument of 'deleteMany' should be array of IDs");
      }
      deleteData = {
        is_deleted: true
      };
      _.extend(deleteData, {
        'deleted_at': new Date()
      });
      if ((whoDeleted != null) && this.config.model.metadata.timestamps) {
        _.extend(deleteData, {
          'who_deleted_id': whoDeleted
        });
      }
      deletedCounter = 0;
      return knex.transaction((function(_this) {
        return function(trx) {
          return Promise.each(ids, function(id) {
            var lookup;
            lookup = {};
            lookup[_this.config.lookupField] = id;
            lookup['is_deleted'] = false;
            return knex(_this.config.model.metadata.tableName).where(lookup).update(deleteData).transacting(trx).then(function(rows) {
              if (rows === 0) {
                throw new Error("'deleteMany()' - " + _this.config.model.metadata.model + " with id = " + id + " does not exist!");
              }
              return deletedCounter += 1;
            });
          });
        };
      })(this)).then(function(finalResult) {
        return finalResult;
      })["catch"]((function(_this) {
        return function(error) {
          if (_this.config.errorLogger != null) {
            _this.config.errorLogger.error(error);
          }
          throw error;
        };
      })(this));
    };

    BaseDAO.prototype.getReturning = function() {
      return this.config.returning;
    };

    return BaseDAO;

  })();

  module.exports = BaseDAO;

}).call(this);
