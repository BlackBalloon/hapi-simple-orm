// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var ForeignKey, Promise, Serializer, _, acceptedFieldTypes,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  Promise = require('bluebird');

  ForeignKey = require('./../fields/foreignKey');

  acceptedFieldTypes = ['ForeignKey', 'BaseField'];

  Serializer = (function() {
    function Serializer() {
      var attributes, base, base1, base2, modelFields;
      attributes = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.attributes = attributes;
      _.each(this.attributes[0], (function(_this) {
        return function(val, key) {
          if (!(indexOf.call(_this.constructor.acceptedParameters, key) >= 0)) {
            throw new TypeError("Parameter '" + key + "' is not accepted in " + _this.constructor.name);
          }
        };
      })(this));
      if ((base = this.constructor.config).readOnlyFields == null) {
        base.readOnlyFields = [];
      }
      if ((base1 = this.constructor.config).fields == null) {
        base1.fields = [];
      }
      if ((base2 = this.constructor.config).excludeFields == null) {
        base2.excludeFields = [];
      }
      if ((this.attributes[0] != null) && (this.attributes[0].fields != null) && this.attributes[0].fields.length > 0) {
        this.constructor.config.fields = _.clone(this.attributes[0].fields);
      }
      if (this.constructor.config.fields.length === 0 && this.constructor.config.readOnlyFields.length === 0) {
        modelFields = _.keys(this.constructor.config.model.prototype.attributes);
        this.serializerFields = _.filter(modelFields, (function(_this) {
          return function(val) {
            var ref;
            return ref = _this.constructor.config.model.prototype.attributes[val].constructor.name, indexOf.call(acceptedFieldTypes, ref) >= 0;
          };
        })(this));
      } else {
        this.serializerFields = _.union(this.constructor.config.fields, this.constructor.config.readOnlyFields);
      }
      _.each(this.serializerFields, (function(_this) {
        return function(val, key) {
          var ref;
          if (typeof val === 'string') {
            if ((_this.constructor.config.model.prototype.attributes[val] != null) && !(ref = _this.constructor.config.model.prototype.attributes[val].constructor.name, indexOf.call(acceptedFieldTypes, ref) >= 0)) {
              throw new Error("Field '" + val + "' is not accepted in ModelSerializer, because it represents m2m/m2o relation!");
            } else if (_this.constructor.config.model.prototype.attributes[val] == null) {
              throw new Error("Key '" + val + "' does not match any attribute of model " + _this.constructor.config.model.metadata.model);
            }
          }
        };
      })(this));
      this.serializerFieldsKeys = _.map(this.serializerFields, (function(_this) {
        return function(val, key) {
          var currentKey;
          currentKey = val.constructor.name === 'String' ? val : (_.keys(val))[0];
          if (indexOf.call(_this.constructor.config.excludeFields, currentKey) < 0) {
            return currentKey;
          }
        };
      })(this));
      this.serializerFieldsKeys = _.without(this.serializerFieldsKeys, void 0);
      if (this.serializerFieldsKeys.length === 0) {
        throw new Error(this.constructor.name + " does not have any field specified!");
      }
    }

    Serializer.prototype.getData = function() {
      return new Promise(function(resolve, reject) {
        return resolve(this.data);
      });
    };

    Serializer.prototype.setData = function(data) {
      return this.data = data;
    };

    return Serializer;

  })();

  module.exports = Serializer;

}).call(this);
