// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var BaseDAO, BaseField, BaseModel, ForeignKey, Joi, ManyToMany, ManyToOne, Promise, _, acceptableMetadataAttributes, fs, knex, knexConf, moduleKeywords,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Joi = require('joi');

  _ = require('underscore');

  fs = require('fs');

  knexConf = require(process.cwd() + '/knexfile');

  knex = require('knex')(knexConf[process.env.NODE_ENV]);

  Promise = require('bluebird');

  ForeignKey = require('../fields/foreignKey');

  BaseField = require('../fields/baseField');

  ManyToMany = require('../fields/manyToMany');

  ManyToOne = require('../fields/manyToOne');

  BaseDAO = require('./../dao/baseDao');

  moduleKeywords = ['extended', 'included'];

  acceptableMetadataAttributes = ['model', 'singular', 'tableName', 'primaryKey', 'timestamps', 'dao', 'errorLogger'];

  BaseModel = (function() {
    BaseModel.injectDao = function(obj) {
      var ref;
      this.objects = function() {
        return obj;
      };
      if ((ref = obj.extended) != null) {
        ref.apply(this);
      }
      return this;
    };

    BaseModel.extend = function(obj) {
      var dao, key, ref, value;
      this.metadata = {};
      for (key in obj) {
        value = obj[key];
        if (!(indexOf.call(moduleKeywords, key) < 0)) {
          continue;
        }
        if (indexOf.call(acceptableMetadataAttributes, key) < 0) {
          throw new Error("The '" + key + "' attribute in Model's metadata is not acceptable.\n Acceptable attributes are " + acceptableMetadataAttributes + ".");
        }
        this.metadata[key] = value;
      }
      if (this.metadata.model == null) {
        this.metadata.model = this.name;
      }
      this.metadata.collectionName = this.name.substring(0, 1).toLowerCase() + this.name.substring(1);
      if (this.metadata.singular == null) {
        this.metadata.singular = this._camelToSnakeCase(this.name);
      }
      if (this.metadata.tableName == null) {
        this.metadata.tableName = this._camelToSnakeCase(this.name) + 's';
      }
      if (this.metadata.primaryKey == null) {
        this.metadata.primaryKey = 'id';
      }
      if (this.metadata.timestamps == null) {
        this.metadata.timestamps = true;
      }
      if (this.metadata.dao == null) {
        this.metadata.dao = BaseDAO;
      }
      dao = this.metadata.dao;
      this.objects = (function(_this) {
        return function() {
          return new _this.metadata.dao(_this);
        };
      })(this);
      if ((ref = obj.extended) != null) {
        ref.apply(this);
      }
      return this;
    };

    BaseModel.include = function(obj) {
      var key, ref, value;
      this.prototype['attributes'] = {};
      this.prototype['fields'] = [];
      for (key in obj) {
        value = obj[key];
        if (!(indexOf.call(moduleKeywords, key) < 0)) {
          continue;
        }
        this.prototype['fields'].push(key);
        this.prototype['attributes'][key] = value;
      }
      _.extend(this.prototype['attributes'], this.prototype.timestampAttributes);
      if ((ref = obj.included) != null) {
        ref.apply(this);
      }
      return this;
    };

    BaseModel.prototype.timestampAttributes = {
      createdAt: new BaseField({
        schema: Joi.date().format('YYYY-MM-DD HH:mm:ss'),
        name: 'createdAt'
      }),
      whoCreated: new BaseField({
        schema: Joi.number().integer().positive(),
        name: 'whoCreated',
        dbField: 'who_created_id'
      }),
      deletedAt: new BaseField({
        schema: Joi.date().format('YYYY-MM-DD HH:mm:ss'),
        name: 'deletedAt'
      }),
      whoDeleted: new BaseField({
        schema: Joi.number().integer().positive(),
        name: 'whoDeleted',
        dbField: 'who_deleted_id'
      }),
      isDeleted: new BaseField({
        schema: Joi.boolean(),
        name: 'isDeleted'
      })
    };

    BaseModel._snakeToCamelCase = function(string, attributes) {
      var camelCase;
      camelCase = string.replace(/(_\w)/g, function(m) {
        return m[1].toUpperCase();
      });
      if (attributes != null) {
        if (attributes[camelCase] instanceof ForeignKey) {
          camelCase.slice(0, -2);
        }
      }
      return camelCase;
    };

    BaseModel._camelToSnakeCase = function(string, attributes) {
      var snakeCase;
      snakeCase = (string.replace(/\.?([A-Z])/g, function(m, n) {
        return '_' + n.toLowerCase();
      })).replace(/^_/, '');
      if (attributes != null) {
        if (attributes[string] instanceof ForeignKey) {
          snakeCase += '_id';
        }
      }
      return snakeCase;
    };

    BaseModel.getSchema = function(fields, partial) {
      var attributesWithSchema;
      attributesWithSchema = _.pick(this.prototype.attributes, (function(_this) {
        return function(val, key) {
          return (val.attributes.schema != null) && !(key in BaseModel.prototype.timestampAttributes) && indexOf.call(_this.prototype.fields, key) >= 0;
        };
      })(this));
      return _.mapObject(attributesWithSchema, function(val, key) {
        var schema;
        schema = val.attributes.schema;
        if (val.attributes.required && !partial) {
          schema = schema.required();
        } else if (!val.attributes.required) {
          schema = schema.allow(null);
        }
        return schema;
      });
    };

    function BaseModel(properties) {
      this["delete"] = bind(this["delete"], this);
      this.save = bind(this.save, this);
      this.validate = bind(this.validate, this);
      this.toJSON = bind(this.toJSON, this);
      this.set = bind(this.set, this);
      this.get = bind(this.get, this);
      this._toDatabaseFields = bind(this._toDatabaseFields, this);
      var error, error1, manyToManyManager, manyToOneManager;
      manyToOneManager = ManyToOne.getManyToOneManager();
      manyToManyManager = ManyToMany.getManyToManyManager();
      _.each(this.attributes, (function(_this) {
        return function(val, key) {
          var throughFields, toModel;
          if (val instanceof ManyToMany) {
            if (!(_.has(val.attributes, 'throughFields'))) {
              toModel = require(val.attributes.toModel);
              throughFields = [];
              throughFields.push(_this.constructor.metadata.singular + '_' + _this.constructor.metadata.primaryKey);
              throughFields.push(toModel.metadata.singular + '_' + toModel.metadata.primaryKey);
              val.attributes.throughFields = throughFields;
            }
            _this[key] = new manyToManyManager(_this, key, val);
          }
          if (val instanceof ManyToOne) {
            if (!(_.has(val.attributes, 'referenceField'))) {
              val.attributes.referenceField = _this.constructor.metadata.singular + '_' + _this.constructor.metadata.primaryKey;
            }
            return _this[key] = new manyToOneManager(_this, key, val);
          }
        };
      })(this));
      try {
        this.set(properties);
      } catch (error1) {
        error = error1;
        throw error;
      }
    }

    BaseModel.prototype._toDatabaseFields = function() {
      var databaseObject, key, ref, value;
      databaseObject = {};
      ref = this.attributes;
      for (key in ref) {
        value = ref[key];
        if (this[key] !== void 0 && value.attributes.dbField && !value.attributes.abstract) {
          databaseObject[value.attributes.dbField] = value.attributes.set != null ? value.attributes.set(this) : this[key];
        }
      }
      return databaseObject;
    };

    BaseModel.prototype.get = function(key, toObject) {
      var lookup;
      if (key in this.attributes) {
        if (this.attributes[key].attributes.get != null) {
          return this.attributes[key].attributes.get(this);
        }
        if (this.attributes[key] instanceof ForeignKey && (this[key] != null)) {
          lookup = {};
          lookup[this.attributes[key].attributes.referenceField] = this[key];
          return this.attributes[key].attributes.referenceModel.objects().get({
            lookup: lookup,
            toObject: toObject
          }).then(function(result) {
            return result;
          })["catch"]((function(_this) {
            return function(error) {
              if (_this.constructor.metadata.errorLogger != null) {
                _this.constructor.metadata.errorLogger.error(error);
              }
              throw error;
            };
          })(this));
        } else {
          return this[key];
        }
      } else {
        throw new TypeError("The '" + key + "' field does not match any attribute of model " + this.constructor.metadata.model + "!");
      }
    };

    BaseModel.prototype.set = function(properties) {
      _.each(properties, (function(_this) {
        return function(value, key) {
          if (key in _this.attributes) {
            if (_this.attributes[key] instanceof ForeignKey) {
              if (value instanceof BaseModel) {
                if (value instanceof _this.attributes[key].attributes.referenceModel) {
                  return _this[key] = value.get(_this.attributes[key].attributes.referenceModel.metadata.primaryKey);
                } else {
                  throw new TypeError("Value for '" + key + "' of " + _this.constructor.metadata.model + " should be FK value or instance of " + _this.attributes[key].attributes.referenceModel.metadata.model + "!");
                }
              } else {
                return _this[key] = value;
              }
            } else {
              return _this[key] = value;
            }
          } else {
            throw new TypeError("The '" + key + "' field does not match any attribute of model " + _this.constructor.metadata.model + "!");
          }
        };
      })(this));
      return this;
    };

    BaseModel.prototype.toJSON = function(arg) {
      var attributes, jsonObject;
      attributes = (arg != null ? arg : {}).attributes;
      if (attributes == null) {
        attributes = _.keys(this.attributes);
      }
      jsonObject = {};
      _.each(attributes, (function(_this) {
        return function(key, val) {
          if (!(_this.attributes[key] instanceof ManyToMany) && !(_this.attributes[key] instanceof ManyToOne)) {
            if (_this.attributes[key] instanceof ForeignKey) {
              return jsonObject[key] = _this[key];
            } else {
              return jsonObject[key] = _this.get(key) !== void 0 ? _this.get(key) : void 0;
            }
          }
        };
      })(this));
      return jsonObject;
    };

    BaseModel.prototype.validate = function(arg) {
      var promises, trx;
      trx = (arg != null ? arg : {}).trx;
      promises = [];
      _.each(this.attributes, (function(_this) {
        return function(value, key) {
          if (value.attributes.abstract == null) {
            return promises.push(value.validate(_this, {
              primaryKey: _this[_this.constructor.metadata.primaryKey],
              trx: trx
            }));
          }
        };
      })(this));
      return Promise.all(promises).then(function(values) {
        var finalValidationError, validationResultObject;
        validationResultObject = {};
        _.each(_.compact(values), function(val, key) {
          return _.extend(validationResultObject, val);
        });
        finalValidationError = {};
        if (!(_.isEmpty(validationResultObject))) {
          _.extend(finalValidationError, {
            error: 'ValidationError',
            fields: validationResultObject
          });
        }
        return finalValidationError;
      });
    };

    BaseModel.prototype.save = function(arg) {
      var ref, returning, toObject;
      ref = arg != null ? arg : {}, returning = ref.returning, toObject = ref.toObject;
      return this.validate().then((function(_this) {
        return function(validationResult) {
          if (!(_.isEmpty(validationResult))) {
            throw validationResult;
          }
          if (_this[_this.constructor.metadata.primaryKey] != null) {
            return _this.constructor.objects().update({
              obj: _this,
              returning: returning,
              toObject: toObject
            }).then(function(res) {
              return res;
            });
          } else {
            return _this.constructor.objects().create({
              data: _this._toDatabaseFields(),
              returning: returning,
              toObject: toObject,
              direct: false
            }).then(function(res) {
              return res;
            });
          }
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          if (_this.constructor.metadata.errorLogger != null) {
            _this.constructor.metadata.errorLogger.error(error);
          }
          throw error;
        };
      })(this));
    };

    BaseModel.prototype["delete"] = function(whoDeleted) {
      var primaryKey;
      primaryKey = this.constructor.metadata.primaryKey;
      if (this[primaryKey] != null) {
        return this.constructor.objects()["delete"](this[primaryKey], whoDeleted).then(function(result) {
          return result;
        })["catch"]((function(_this) {
          return function(error) {
            if (_this.constructor.metadata.errorLogger != null) {
              _this.constructor.metadata.errorLogger.error(error);
            }
            throw error;
          };
        })(this));
      } else {
        throw new Error("This " + this.constructor.metadata.model + " does not have primary key set!");
      }
    };

    return BaseModel;

  })();

  module.exports = BaseModel;

}).call(this);
