// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var BaseField, BaseModel, Joi, Promise, _, knex, knexConf,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Joi = require('joi');

  BaseModel = require('./../model/baseModel');

  _ = require('underscore');

  knexConf = require(process.cwd() + '/knexfile');

  knex = require('knex')(knexConf[process.env.NODE_ENV]);

  Promise = require('bluebird');

  BaseField = (function() {
    BaseField.schemaErrorMessages = {
      language: {
        any: {
          required: 'jest polem obowiązkowym',
          empty: 'nie może być puste'
        },
        number: {
          base: 'musi być liczbą',
          min: 'wartość musi być większa lub rowna {{limit}}',
          max: 'wartość musi być mniejsza lub rowna {{limit}}'
        }
      }
    };

    BaseField.validationMethods = {
      schema: 'validateSchema',
      unique: 'validateUnique'
    };

    BaseField.acceptedParameters = ['required', 'unique', 'schema', 'dbField', 'abstract', 'name', 'primaryKey', 'modelMeta', 'errorMessages', 'set', 'get'];

    BaseField._camelToSnakeCase = function(val) {
      var snakeCase;
      snakeCase = (val.replace(/\.?([A-Z])/g, function(m, n) {
        return '_' + n.toLowerCase();
      })).replace(/^_/, '');
      return snakeCase;
    };

    function BaseField() {
      var attributes;
      attributes = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.attributes = attributes;
      this.getDbField = bind(this.getDbField, this);
      this.validate = bind(this.validate, this);
      this.validateUnique = bind(this.validateUnique, this);
      this.validateSchema = bind(this.validateSchema, this);
      this.attributes = _.reduce(this.attributes, function(memo, value) {
        return value;
      });
      if (this.attributes.primaryKey && !_.has(this.attributes, 'name')) {
        this.attributes['name'] = 'id';
      }
      if (!(this.constructor.name === 'ForeignKey') && _.has(this.attributes, 'name')) {
        this.attributes['dbField'] = this.getDbField(this.attributes.name);
      }
      if (this.acceptedParameters == null) {
        this.acceptedParameters = _.clone(this.constructor.acceptedParameters);
      }
      if (this.validationMethods == null) {
        this.validationMethods = _.clone(this.constructor.validationMethods);
      }
      _.each(this.attributes, (function(_this) {
        return function(val, key) {
          if (indexOf.call(_this.acceptedParameters, key) < 0) {
            throw new TypeError("Key '" + key + "' is not accepted in field " + _this.attributes.name + "!");
          }
        };
      })(this));
    }

    BaseField.prototype.validateSchema = function(value) {
      return Joi.validate(value, this.getSchema(), this.constructor.schemaErrorMessages, function(err, value) {
        if (err) {
          return err.details[0].message;
        }
      });
    };

    BaseField.prototype.validateUnique = function(value, arg) {
      var bindings, finalQuery, primaryKey, query, trx;
      primaryKey = arg.primaryKey, trx = arg.trx;
      query = "SELECT EXISTS(SELECT 1 FROM " + this.attributes.modelMeta.tableName + " WHERE " + this.attributes.dbField + " = ? AND is_deleted = false";
      bindings = [value];
      if (primaryKey != null) {
        query += " AND " + this.attributes.modelMeta.primaryKey + " <> ?";
        bindings.push(primaryKey);
      }
      query += ")";
      finalQuery = knex.raw(query, bindings);
      if (trx != null) {
        finalQuery.transacting(trx);
      }
      return finalQuery.then((function(_this) {
        return function(result) {
          if (result.rows[0].exists === true) {
            return _this.attributes.errorMessages['unique'] || (_this.attributes.modelMeta.model + " with this " + _this.attributes.name + " (" + value + ") already exists!");
          }
        };
      })(this))["catch"](function(error) {
        throw error;
      });
    };

    BaseField.prototype.validate = function(obj, arg) {
      var currentFieldValue, primaryKey, trx, validationPromises;
      primaryKey = arg.primaryKey, trx = arg.trx;
      currentFieldValue = obj[this.attributes.name];
      validationPromises = [];
      _.each(this.attributes, (function(_this) {
        return function(val, key) {
          if (key in _this.validationMethods) {
            return validationPromises.push(_this[_this.validationMethods[key]](currentFieldValue, {
              primaryKey: primaryKey,
              trx: trx
            }));
          }
        };
      })(this));
      return Promise.all(validationPromises).then((function(_this) {
        return function(validationPromisesResults) {
          var err, returnObj;
          returnObj = {};
          err = _.find(validationPromisesResults, function(val) {
            return val != null;
          });
          if (err != null) {
            returnObj[_this.attributes.name] = err;
            return returnObj;
          }
        };
      })(this));
    };

    BaseField.prototype.getDbField = function(val) {
      if (!_.has(this.attributes, 'dbField')) {
        return this.constructor._camelToSnakeCase(val);
      }
      return this.attributes.dbField;
    };

    BaseField.prototype.getSchema = function() {
      var schema;
      if (!_.has(this.attributes, 'schema')) {
        throw new Error("Field '" + this.attributes.name + "' does not have its schema!");
      }
      schema = this.attributes.schema;
      if (this.attributes.required) {
        schema = schema.required();
      } else {
        schema = schema.allow(null);
      }
      return schema;
    };

    return BaseField;

  })();

  module.exports = BaseField;

}).call(this);
