// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var BaseField, BaseModel, ForeignKey, Joi, _, foreignKeyAcceptedParameters, foreignKeyValidationMethods, fs, knex, knexConf,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('underscore');

  knexConf = require(process.cwd() + '/knexfile');

  knex = require('knex')(knexConf[process.env.NODE_ENV]);

  fs = require('fs');

  Joi = require('joi');

  BaseField = require('./baseField');

  BaseModel = require('./../model/baseModel');

  foreignKeyAcceptedParameters = ['foreignKey', 'referenceModel', 'referenceField'];

  foreignKeyValidationMethods = {
    foreignKey: 'validateForeignKey'
  };

  ForeignKey = (function(superClass) {
    extend(ForeignKey, superClass);

    function ForeignKey() {
      var attributes, referenceFieldSchema, referenceModel;
      attributes = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.getDbField = bind(this.getDbField, this);
      this.validateForeignKey = bind(this.validateForeignKey, this);
      this.constructor.acceptedParameters = _.union(BaseField.acceptedParameters, foreignKeyAcceptedParameters);
      this.constructor.validationMethods = _.extend(BaseField.validationMethods, foreignKeyValidationMethods);
      referenceModel = attributes[0].referenceModel;
      _.extend(attributes[0], {
        'foreignKey': true
      });
      if (!(_.has(attributes[0], 'referenceField'))) {
        _.extend(attributes[0], {
          'referenceField': referenceModel.metadata.primaryKey
        });
      }
      if (!(_.has(attributes[0], 'name'))) {
        _.extend(attributes[0], {
          'name': referenceModel.metadata.model.substring(0, 1).toLowerCase() + referenceModel.metadata.model.substring(1)
        });
      }
      if (!(_.has(attributes[0], 'dbField'))) {
        _.extend(attributes[0], {
          'dbField': this.getDbField(attributes[0].name)
        });
      }
      referenceFieldSchema = referenceModel.prototype.attributes[attributes[0].referenceField].attributes.schema;
      if (!(_.has(attributes[0], 'schema'))) {
        _.extend(attributes[0], {
          schema: referenceFieldSchema
        });
      }
      ForeignKey.__super__.constructor.apply(this, arguments);
    }

    ForeignKey.prototype.validateForeignKey = function(value, arg) {
      var finalQuery, sqlQuery, trx;
      trx = (arg != null ? arg : {}).trx;
      if (value != null) {
        sqlQuery = "SELECT EXISTS(SELECT 1 FROM " + this.attributes.referenceModel.metadata.tableName + " WHERE " + this.attributes.referenceField + " = ? AND is_deleted = false)";
        finalQuery = knex.raw(sqlQuery, [value]);
        if (trx != null) {
          finalQuery.transacting(trx);
        }
        return finalQuery.then((function(_this) {
          return function(result) {
            if (result.rows[0].exists === false) {
              return _this.attributes.errorMessages['foreignKey'] || ("Specified " + _this.attributes.name + " does not exist!");
            }
          };
        })(this))["catch"](function(error) {
          throw error;
        });
      }
    };

    ForeignKey.prototype.getDbField = function(val) {
      if (!_.has(this.attributes, 'dbField')) {
        return this.constructor._camelToSnakeCase(val) + '_id';
      }
      return this.attributes.dbField;
    };

    return ForeignKey;

  })(BaseField);

  module.exports = ForeignKey;

}).call(this);
